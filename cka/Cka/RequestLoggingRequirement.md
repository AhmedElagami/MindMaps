# Request Logging Requirement

## Content

### ❓ Explain what the following auditctl command does and what specific activities it monitors.
The `auditctl` command uses a common Linux audit daemon to audit access to the docker binary. It also audits attempts to change the binary's file attributes.

```bash
$ auditctl -w /usr/bin/docker -p wxa -k audit-docker
```

The `-w` flag watches the file at `/usr/bin/docker`. The `-p` flag specifies the permissions to watch for: `w` for write, `x` for execute, and `a` for attribute change. The `-k` flag sets a key (`audit-docker`) to help identify the audit records generated by this rule.

### ❓ What is the fundamental purpose of non-repudiation in information security?
Non-repudiation provides proof about something. In the context of information security, non-repudiation is proving certain individuals carried out certain actions.

### ❓ What are the six specific elements that non-repudiation must prove about an action or event and which two are typically the most difficult to establish?
Non-repudiation includes the ability to prove:

- What happened
- When it happened
- Who made it happen
- Where it happened
- Why it happened
- How it happened

Answering the last two (why it happened and how it happened) can be the hardest and usually requires the correlation of several events over a period of time.

### ❓ What Kubernetes component's audit events can help provide answers for non-repudiation requirements?
Auditing Kubernetes API server events can help answer these questions about non-repudiation.

### ❓ Analyze the following full API server audit event JSON and explain what security-relevant information it provides for non-repudiation purposes.
The API server audit event provides comprehensive security-relevant information for non-repudiation:

```json
{
  "kind":"Event",
  "apiVersion":"audit.k8s.io/v1",
  "metadata":{ "creationTimestamp":"2022-11-11T10:10:00Z" },
  "level":"Metadata",
  "timestamp":"2022-11-11T10:10:00Z",
  "auditID":"7e0cbccf-8d8a-4f5f-aefb-60b8af2d2ad5",
  "stage":"RequestReceived",
  "requestURI":"/api/v1/namespaces/default/persistentvolumeclaims",
  "verb":"list",
  "user": {
    "username":"fname.lname@example.com",
    "groups":[ "system:authenticated" ]
  },
  "sourceIPs":[ "123.45.67.123" ],
  "objectRef": {
    "resource":"persistentvolumeclaims",
    "namespace":"default",
    "apiVersion":"v1"
  },
  "requestReceivedTimestamp":"2022-11-11T10:10:00.123456Z",
  "stageTimestamp":"2022-11-11T10:10:00.123456Z"
}
```

This event provides non-repudiation by documenting:
- **What happened**: A list operation on persistentvolumeclaims in the default namespace
- **When it happened**: 2022-11-11T10:10:00Z with precise timestamps
- **Who made it happen**: User "fname.lname@example.com" from group "system:authenticated"
- **Where it happened**: Source IP 123.45.67.123 accessing /api/v1/namespaces/default/persistentvolumeclaims
- The unique audit ID ensures this specific event cannot be repudiated

### ❓ Besides the API server, what three types of Kubernetes components should also have their audit logs collected for comprehensive non-repudiation?
At a minimum, you should collect audit logs from container runtimes, kubelets, and the applications running on your cluster. You should also audit non-Kubernetes infrastructure, such as network firewalls.

### ❓ Why is it critical that centralized log stores for audit data must be secure?
If the centralized log store isn't secure, you won't be able to trust the logs, and their contents can be repudiated.

### ❓ What specific type of system daemon can help provide non-repudiation for file tampering on Kubernetes nodes?
To provide non-repudiation relative to tampering with binaries and configuration files, it might be useful to use an audit daemon that watches for write actions on certain files and directories on your Kubernetes control plane nodes and worker nodes.

### ❓ Explain what the following full audit system call event reveals about the execution of the docker command and how this contributes to non-repudiation.
This audit system call event provides detailed non-repudiation evidence for docker command execution:

```bash
type=SYSCALL msg=audit(1234567890.123:12345): arch=abc123 syscall=59 success=yes \
exit=0 a0=12345678abca1=0 a2=abc12345678 a3=a items=1 ppid=1234 pid=12345 auid=0 \
uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=1 comm="docker" \
exe="/usr/bin/docker" subj=system_u:object_r:container_runtime_exec_t:s0 \
key="audit-docker" type=CWD msg=audit(1234567890.123:12345):  cwd="/home/firstname"\
type=PATH msg=audit(1234567890.123:12345): item=0 name="/usr/bin/docker"\
 inode=123456 dev=fd:00 mode=0100600 ouid=0 ogid=0 rdev=00:00...
```

The event reveals:
- **What happened**: Successful execution of the docker command (syscall=59 success=yes)
- **Who executed it**: User with UID 0 (root) from session 1, working directory "/home/firstname"
- **Which binary was used**: "/usr/bin/docker" with specific inode and device details
- **Security context**: SELinux context "system_u:object_r:container_runtime_exec_t:s0"
- **Process details**: PID 12345, parent PID 1234

This provides irrefutable evidence that cannot be repudiated about the exact execution of the docker command.

### ❓ How does combining Kubernetes audit features with system-level audit logs create a comprehensive non-repudiation capability?
When combined and correlated with Kubernetes' audit features, audit logs like this create a comprehensive and trustworthy picture that cannot be repudiated.

### ❓ What are the two critical capabilities that organizations must have when security breaches occur according to security monitoring principles?
When breaches happen, it's vital you can do at least two things:

1. Recognize that a breach has occurred
2. Build a detailed timeline of events that cannot be repudiated

### ❓ What four post-event questions can reliable auditing timelines help answer following a security incident?
The ability to build a reliable timeline helps answer the following post-event questions:

- What happened
- How did it happen
- When did it happen
- Who did it

In extreme circumstances, this information can be called upon in court.

### ❓ What organization publishes the industry-standard Kubernetes security benchmark, what tool is used to run these tests, and what limitation does kube-bench have when used with hosted Kubernetes services?
The Center for Information Security (CIS) publishes an industry-standard benchmark for Kubernetes security, and Aqua Security (aquasec.com) has written an easy-to-use tool called kube-bench to run the CIS tests against your cluster and generate reports. Unfortunately, kube-bench can't inspect the control plane nodes of hosted Kubernetes services.

### ❓ How can kube-bench reports be utilized in the aftermath of security incidents for configuration analysis?
You can use kube-bench reports as a baseline for use in the aftermath of incidents. This allows you to compare the kube-bench reports from before and after the incident and determine if and where any configuration changes occurred.

### ❓ How can kube-bench reports serve as a baseline in incident response scenarios?
You can use kube-bench reports as a baseline for use in the aftermath of incidents. This allows you to compare the kube-bench reports from before and after the incident and determine if and where any configuration changes occurred.

### ❓ What is the definition of forensics according to the text, and when is it particularly important?
Forensics is the science of collecting and examining available evidence to construct a trail of events, especially when you suspect malicious behavior.

### ❓ What are the two primary methods applications use to send logs, and why is it important to research each application's logging behavior?
However, not all applications send their logs to the same place. Some send them to their container's standard out (stdout) or standard error (stderr) streams where your logging tools can pick them up alongside container logs. However, some send logs to proprietary log files in bespoke locations. Be sure to research this for each application and configure things so you don't miss logs.

### ❓ How does container application density impact log management, and what types of tools are needed to handle this challenge?
A key advantage of containers is application density --- you can run a lot more applications on your servers and in your datacenters. This results in massive amounts of log data and audit data that is overwhelming without specialized tools to sort and make sense of it. Fortunately, advanced tools exist that not only store the data, but can use it for proactive analysis as well as post-event reactive analysis.

### ❓ Why are exec sessions by human users considered security-relevant events that warrant investigation?
Exec sessions by human users: Exec sessions grant shell-like access to containers and are typically only used to troubleshoot issues. You should investigate exec sessions that aren't for troubleshooting and consider deleting them to prevent tampering.

### ❓ Why should attempts to access the cluster from the internet be monitored, and what does a successful attempt typically indicate?
Attempts to access the cluster from the internet: It's a common practice to prevent access to the control plane from the internet. As such, you should monitor for successful and unsuccessful attempts to connect to the control plane from the internet, and successful attempts will typically indicate a security misconfiguration you should fix.

